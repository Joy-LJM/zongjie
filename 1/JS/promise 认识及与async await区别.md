### promise   
- 概念
  - promise对象是es6对异步编程对一种解决方案,它里面存放着一个尚未完成且预计在未来完成的异步操作,
  - 这个操作有三种状态:pending\fulfilled\rejected,分别代表这进行中、已成功和已失败
  - 进行中pending状态的改变只有两种可能,要么成功,要么失败,它的状态一旦更新，就不会再改变

- 背景
  - 在开发中,当出现回调地狱的时候,异步任务代码一层嵌套着一层,很难维护
  - 比如,我们常见的调接口拿数据,如果第二次请求传送的参数是需要第一次请求返回的结果,那么第二次请求只能写在第一次请求成功的回调函数里面,当有多个这种异步请求的需求，就形成了比较深的嵌套

- promise理解
  - promise是一个构造函数,接收一个函数作为参数,这个函数有两个参数,resolve和reject,这两个参数也是两个函数
  - resolve函数的作用是把promise对象的状态从进行中变为成功,并将异步操作成功的结果作为参数传递出去到then里面
  - reject函数到作用是把promise对象到状态从进行中变为失败,并将异步操作报出的错误作为参数传递到then里面
  - 而then()方法的第一个参数就是resolved成功到的回调函数,这个函数接收的参数就是异步操作成功的结果,最后返回的结果是一个新的promise实例
  - catch()方法可以接收promise对象的失败状态,也即是异常操作抛出错误时,就会调用catch方法,这个方法里面的回调可以收到错误信息。当then方法中只有一个函数时，既可以检测then方法中的错误信息，也可以检测promise构造函数中的错误信息，当then方法中有两个函数时，只能检测then方法中的错误信息 
  - 其实then方法的第二个参数也是失败状态的回调,可以接收到错误信息,一般都不使用,基本上就没用过,直接用catch来捕获异常就行.其实区别还是有一点都,如果是进入成功状态的回调函数内部有发生错误,catch可以捕捉到，如果没有catch，我们是无法获知错误信息的
  - 每次对promise调用then方法之后,都会创建一个新的promise对象返回,就可以继续使用then方法,可以实现链式调用





Promise是解决回调地狱的，他有三种状态，pending进行中，fulfilled,rejected,Promise本质是一个状态机，状态一旦改变，就不会再变回来了，也就是不可逆的，而Promise的执行顺序跟事件循环机制有关，事件循环机制又分为三部分调用栈，webAPI和任务队列，任务队列又分为宏任务和微任务，队列的执行的顺序是:宏先微后，代码在执行的过程中，会把整个script放到调用栈中，然后从上往下执行，同步代码直接输出，异步代码放到webAPI中，等待分配任务队列，当调用栈被清空的后，webAPI开始分配任务，任务分配完毕后，开始执行微任务



### promise与async和await的区别

答：相同点：都用来解决异步编程的解决办法

​	不同点：1.async 和await他遵循的是Generator 函数的语法糖 ，async相当于Generator中的*，await相当于yield表达式

​			2.使用async函数可以让代码简洁很多，不需要像Promise一样需要些then去获取成功与失败的结果，await 与async必须一起使用才可以

​			3错误处理： Async/Await 让 try/catch 可以同时处理同步和异步错误。在下面的promise示例中，try/catch 不能处理 JSON.parse 的错误，因为它在Promise中。我们需要使用 .catch，这样错误处理代码非常冗余。并且，在我们的实际生产代码会更加复杂 

​			4错误栈 ， 如果 Promise 连续调用，对于错误的处理是很麻烦的。你无法知道错误出在哪里 ，　  async/await中的错误栈会指向错误所在的函数 