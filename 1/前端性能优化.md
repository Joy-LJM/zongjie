- 减少请求资源大小或者次数
  - 尽量合并和压缩css和js文件
  - 尽量所使用的字体图标或者SVG图标来代替传统png图
  - 使用雪碧图
  - 采用图片的懒加载（延迟加载）
  - 能用css做的效果，不要用js做，能用原生js做的，不要轻易去使用第三方插件。

图片静态资源用cdn加速

- 代码优化相关
  - 在js中尽量减少闭包的使用
  - 减少对DOM操作，主要是减少DOM的重绘与回流
  - 在js中避免嵌套循环和"死循环"
  - css选择器解析规则所示从右往左解析的。减少元素标签作为对后一个选择对象
  - 在事件绑定中，尽可能使用事件委托，减少循环给DOM元素绑定事件处理函数

- 利用浏览器的缓存技术

- 服务端渲
  - 整个html片段的工作在服务端完成，直接返回给客户端渲染。

- Webpack 打包的优化
  - 提取公共代码
  - 按需引入：第三方库可以通过按需引入的方式加载。避免引入不需要使用的部分
  - 减少图片使用


### 防抖节流
- 节流 -射手攻速（每隔一段时间触发一次）
  - 滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流。
- 防抖 -法师CD（一次触发后隔段时间才能触发）
  - 有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。

### 使用浏览器缓存

### vue 性能优化
- 图片资源懒加载：使用 Vue 的 vue-lazyload 插件
- 路由懒加载：
- v-if 和 v-show 区分使用场景
  - v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景
  - v-show 则适用于需要非常频繁切换条件的场景
- computed 和 watch  区分使用场景
  - 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算
  - 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch
- 长列表性能优化
  - 有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据
  - 可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。
- 事件的销毁
  - Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器
  - 如果在 js 内使用 addEventListener 等方式是不会自动销毁的
  - 需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露

- 可以使用keep-alive
